bp at $2A8
let's find out how we copy tiles to memory
first hit with DE=$4020, HL=$B333
$B332 is mapped from $13332 in rom
a = 0x07 (confirmed from $B332)
this slowly starts writing out every 4th byte in vram
sometimes it moves hl forwards, sometimes it doesn't
it's basically run length encoding
so for example

07 00 81 01 07 00 81 FF 08 01 9C 29 C7 4F 57 E7 03 03 01 FE FF FF EF E3 E0 C0 80 7F EE D5
00013350  C9 E5 FA 61 1E A7 6F B7 BF 03 7F 89 BF D7 D7 BB E3 BA CD FD B6 08 00 84 ...a..o.................
00013368  0C 03 0F 3F 03 7F A1 1E 7E FE FD FD EA D5 98 1F A5 5A 8D 7F 1F 9F 7F FF ...?....~........Z......
00013380  07 18 23 4F 5C 98 B8 B0 E0 18 04 02 02 01 0D 1D 08 FF 81 80 02 B0 02 43 ..#O\..................C
00013398  8E 21 18 07 1D 39 F9 F2 E2 84 18 E0 00 F0 FC 02 FE 03 FF 04 00 81 F0 03 .!...9..................
000133B0  F8 05 FF 83 FE 70 00 03 FC 81 78 04 00 02 FF 8C DF FF FD FF DF FF F7 D6 .....p....x.............
000133C8  F5 F5 7B 9B 03 EB 02 F7 86 D7 E7 E8 E7 EF 01 0D 00 83 01 12 69 07 FF 82 ..{.................i...
000133E0  00 FC 03 C2 84 FC C0 C0 00 06 C2 8A 7C 00 7C C0 C0 7C 06 06 FC 00 03 C2 ............|.|..|......
000133F8  81 FE 03 C2 09 00 89 7E C0 C0 7C 06 06 FC 00 FF 06 18 9A 00 38 64 64 7C .......~..|.........8dd|
00013410  FE C2 C2 00 FC C6 C6 FC CC C6 C6 00 FC C2 C2 FC C2 C2 FC 00 7C 05 C2 91 ....................|...
00013428  7C 00 C2 E2 F2 DA CE C6 C2 3C 42 9D A1 A1 9D 42 3C 21 00 82 0C 1C 04 0C |........<B....B<!......
00013440  83 1E 00 7C 03 C6 8F 7E 06 06 00 7C C2 C2 7C C2 C2 7C 00 7C C0 FC 03 C6 ...|...~...|..|..|.|....
00013458  81 7C 02 FF 02 7F 84 3F 1F 07 00 0D FF 83 EF C7 01 1C 00 8C 03 0C 30 C0 .|.....?..............0.
00013470  00 00 0E 70 83 0C 30 C0 08 00 86 01 06 08 30 40 80 0B 00 87 03 07 0F 0F ...p..0.......0@........
00013488  1F 7F FF 04 00 83 03 1F 7F 21 FF 82 0F 10 02 20 02 40 02 80 82 F8 0E 02 .........!..... .@......
000134A0  07 03 03 81 01 03 00 02 80 03 C0 83 00 03 1C 05 10 82 1F E0 04 00 93 03 ........................

7x write 00 (every 4th byte)
1x write 01
7x write 00
1x write FF
8x write 01
28x write the next characters (the 0x9C = 0x80 for high bit + 0x1C = 28)
 - 29 C7 4F 57 E7 03 03 01 FE FF FF EF E3 E0 C0 80 7F EE D5 C9 E5 FA 61 1E A7 6F B7 BF 
3x write 7F
9x write next characters
 - BF D7 D7 BB E3 BA CD FD B6
 [all matches up with reading vram so far]
i guess let's bp on $29F and see where hl got to
hl ends at 0xBEDB = 13EDB in file
0xBA9 = 2985 bytes
let's build our own unpacker?
start = 78642
length = 2985

unpacker working

bp at $7ec gets us just after all tiles and palettes and screen has been loaded

so ran some breakpoints, looks like _LABEL_76D_94 just loads the first screen
so this means that the stuff that loads the rest of the things is buried somewhere else?
we're a bit lucky in that RST $30 seems to be used so far for loading the palette so we can probably bp that in future
but we do also have enough data here to rebuild the start screen
rst $30 gets hit every few seconds, i guess it's related to the music too?
it doesn't get hit when doing the map screen
does get hit just as the new palette turns up for the first level
sp = EC 02 11 11 E6 0A (return address should be 0x1111 but might be 0xAE6)
definitely changed palette here
and returned us to 0x1111
called by AE6
none of that chunk got disassembled... 
ok before AE6 was 0062... and nothing before that... did we get chucked here by an interrupt?
looks like AC3 might be the function as debugger doesn't want to drop us in any earlier than that

having some issues getting full disasm, so looking into memory pages
it looks like alex just has first 2 banks both pointing at rom bank 0
but third changes a lot - mostly on 2, sometimes gets moved to 4 or 5 :/ weird
good news is memory model looks roughly like 0-4000 is static, 4000-8000 probably won't change (/shrug), and 8000-c000 = often changes, multiple times per frame
so code should be reliable, data less so... although there is useful code at 4000+ ?!

what do we do here? should we aim to get the main screen loaded? that would be a good start, and then we can look at the level loading after that
i'd be happy calling _LABEL_76D_94 the loading screen loop (at least after we pass the jp   nz, _LABEL_7EC_95)

put a bp there, doesn't get called after game loads so im happy with $76D = start screen
when bp gets hit, return address is $62
instruction at $60 (or $61, idk) is rst $20 which is a jmp based on hl
is it safe to say that $20, possibly even back at $53, is the level/screen loader?
let's bp on $53
$53 is only hit for start screen, but bp on $20 might be more useful
$20 gets hit tons even in the loading screen
sometimes goes to 76D (hl=3b)
sometimes gets called with hl=127, a=0, and sends us to 842
let's check that out then
also massive stacktrace here - 107, 254, C300, C6C0, 76D?!
looks like we got called by the interrupt handler going to _LABEL_1B_39
so pattern is follows
start screen/always
- rst $20 with hl=3b, a=0
- rst $20 with hl=127, a=0

loading map
- above two and
- sometimes rst $20 with hl=2890, a=62 (this jumps to 39DB)
- sometimes rst $20 with hl=127, a=3 (this jumps to 1A01)
- sometimes rst $20 with hl=3b, a=3 (this jumps to 194F)

in level it's the same shit with different numbers

so it's pretty clear - $20 is a central part of the message pump
$1b is also important for some reason - the high bit of a ends up being a flag and then getting zeroed out - rle?

now we know this let's go through start again
stack setup then game on at $85
$85 does the following:
- initialise mem bank 2 to cartridge bank 2
- set all 4 sound channels to off
- clears all RAM
- does some big expensive loop thing with no side effects?! ($343)
- does some sort of console localisation/version check on the magic $DE/$DF ports, stores result in $C005
- initialises VDP registers and zeroes VRAM (stores state of VDP register 1 in $C004)
- finally enables interrupts and display (checking against $C004)

vars so far
C000-C003 = a 32 bit number?
C004 = VDP register 1 (cached for easy enable/disable)
C005 = some localisation stuff (0 for us)
C006 = joypad sync (the demos in start screen actually use this)
C007 = flickers when character changes direction
C008 = used by $2E6 to wake up from sleep, also used to decide what to do in interrupt handler (maybe it's set with options then wait for int?)
C009 = alternates when alex walks, 0B/0C, and goes briefly to 0D when punching
C01F = used as part of rst $20 to decide part of your long jump, also referenced in interrupt handler? maybe pointer to some state object?
C020-C023 = another 32 bit number? looks to be the number of the preview that is playing at the start screen
C07C = changed when i punched a question mark box and got the ring
C0AB-C0B0 = hscroll
C0B9-C0C6 = vscroll
C0AF = scroll counter?
C0AB = scroll counter?
C0B9 = scroll counter?
C0BD = scroll counter?
C100 = constantly ticking while game is running but just low nybble
C10D = constantly incremnting while game is running
C111-C1F5 = something that gets reset at $9DF3 - some locally stored tile data?
C11B-C182 = all seems to change with the music
C226 = gets set to 3C as part of start screen init
C700-C7FF = local cache of sprite table ($1F7 syncs this to VRAM)

easy so far, just initalising everything, and then display and interrupts enabled for when we hit $53

$57 is the loading screen loop, but $53 zeroes out $C01F first... this is where we get our a for when we jump to $20
at least we know $57 is actually the start of everything, and by extension, $76D
var C01F is quite interesting - when it's 00 or 80 we get sent to 76D, but when it's 80 we do the short circuit
looks like we set it to 02 but only the non-disassembled code makes other changes :/

i think the hard part is going to be mapping out all the stuff that can go via $20, but it's a bit of a blessing too
- we have some sort of event loop here and pull a variety of methods out that should serve similar purposes

but first things first - let's port the alex kidd loading screen!

first time to 76D: vram empty, (h1) is 0 so carry on through
once we get to $784 sprite info table populated: 64xE0, 64x00, 64xE0, 64x00
i think this is done in the interrupt handler though - we enable interrupts and sleep
looks like $212 is the culprit here
stack trace goes $EA (inside interrput handler)
looks like is $E7
ok so $1F7 does a bunch of stuff
we have 512 tiles/sprites - we copy from C700-C73F to VRAM 3800-383F, then from C780-C7FF to 3880-38FF
basically we copy the first quarter and second half of C700, and the last quarter happens to be blank (hence the alternating chunks of E0/00)
it feels more and more like $C008 is an interrupt call - hit it and it'll call your interrupt, and sleep/busywait until it returns (locks etc)
anyway we're losing focus

found out what the E0 is - it's 224 (past the end of the screen). the E0/00 thing sets all sprites to sprite #00 and position 224,224 (off end of screen)